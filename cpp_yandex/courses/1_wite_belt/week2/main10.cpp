/*
У каждого из нас есть повторяющиеся ежемесячные дела, каждое из которых нужно выполнять в конкретный день каждого месяца: оплата счетов за электричество, абонентская плата за связь и пр. Вам нужно реализовать работу со списком таких дел на месяц, а именно, реализовать набор следующих операций:

ADD i s
Назначить дело с названием s на день i текущего месяца.

DUMP i
Вывести все дела, запланированные на день i текущего месяца.

NEXT
Перейти к списку дел на новый месяц. При выполнении данной команды вместо текущего (старого) списка дел на текущий месяц создаётся и становится активным (новый) список дел на следующий месяц: все дела со старого списка дел копируются в новый список. После выполнения данной команды новый список дел и следующий месяц становятся текущими, а работа со старым списком дел прекращается.  При переходе к новому месяцу необходимо обратить внимание на разное количество дней в месяцах:

если следующий месяц имеет больше дней, чем текущий, «дополнительные» дни необходимо оставить пустыми (не содержащими дел);

если следующий месяц имеет меньше дней, чем текущий, дела со всех «лишних» дней необходимо переместить на последний день следующего месяца.

Замечания
Историю списков дел хранить не требуется, работа ведется только с текущим списком дел текущего месяца. Более того, при создании списка дел на следующий месяц, он «перетирает» предыдущий список.

Обратите внимание, что количество команд NEXT в общей последовательности команд при работе со списком дел может превышать 11.

Начальным текущим месяцем считается январь.

Количества дней в месяцах соответствуют Григорианскому календарю с той лишь разницей, что в феврале всегда 28 дней.

Формат ввода
Сначала число операций Q, затем описания операций.

Названия дел s уникальны и состоят только из латинских букв, цифр и символов подчёркивания. Номера дней i являются целыми числами и нумеруются от 1 до размера текущего месяца.

Формат вывода
Для каждой операции типа DUMP в отдельной строке выведите количество дел в соответствующий день, а затем их названия, разделяя их пробелом. Порядок вывода дел в рамках каждой операции значения не имеет.

Пример
Ввод
12
ADD 5 Salary
ADD 31 Walk
ADD 30 WalkPreparations
NEXT
DUMP 5
DUMP 28
NEXT
DUMP 31
DUMP 30
DUMP 28
ADD 28 Payment
DUMP 28

Вывод
1 Salary
2 WalkPreparations Walk
0
0
2 WalkPreparations Walk
3 WalkPreparations Walk Payment

Указание
Для дописывания всех элементов вектора v2 в конец вектора v1 удобно использовать метод insert:
v1.insert(end(v1), begin(v2), end(v2));

Кроме того, элементом вектора может быть любой тип, в том числе и другой вектор. Например, vector<vector<int>> — это вектор, элементами которого являются вектора целых чисел (то есть двумерный массив). Пример использования:
vector<vector<int>> m(10); // Создаём вектор из десяти векторов целых чисел
m[0].push_back(5);  // Добавляем элементы в первый вектор
m[0].push_back(15);
cout << m[0][1]; // Выведет 15 — второй элемент первого вектора

m[1].push_back(3);
for (int x : m[1]) {
	// Перебираем все элементы второго
}
*/

// https://gcc.godbolt.org

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

int
main()
{
	vector<int> days_in_month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
	vector<vector<string>> activities(31);
	int month = 0;

	int q;
	cin >> q;
	for (int i = 0; i < q; i++) {
		string op;
		cin >> op;
		if (op == "ADD") {
			int day;
			string s;
			cin >> day >> s;
			activities[day - 1].push_back(s);
		} else if (op == "NEXT") {
			month = (month + 1) % 12;
			int sz = days_in_month[month];
			if (sz < activities.size()) {
				auto& finish_day = activities[sz - 1];
				for (int i = sz; i < activities.size(); i++)
					finish_day.insert(end(finish_day), begin(activities[i]), end(activities[i]));

			}
			activities.resize(sz);
		} else if (op == "DUMP") {
			int day;
			cin >> day;
			auto d =  activities[day - 1];
			cout << d.size() << " ";
			for (auto w : d)
				cout << w << " ";
			cout << endl;
		}
	}

	return 0;
}
